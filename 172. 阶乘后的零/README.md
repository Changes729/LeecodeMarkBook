> From：https://leetcode-cn.com/problems/factorial-trailing-zeroes/

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

 

**示例 1：**

```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

**示例 2：**

```
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

**示例 3：**

```
输入：n = 0
输出：0
```

 

**提示：**

- `0 <= n <= 104`

## 算法

**算法一**

我最开始设想的算法就是阶乘一步步去算，遇到结尾是0的，就除以10，然后记熟加一，但是出错了。众所周知，阶乘10以上的数字是多么庞大，一般都需要使用数组去存放如此大数。所以方案一是失败的，这让我不得不去寻找规律，从而引出了算法二。

**算法二**

题目目标是的出阶乘数结尾0的个数。能在数末尾加0的乘法，只有乘以10的倍数，或者是5*2。根据这个规律，我只需要将阶乘中的5和2以及10找出来即可。

所以我就写了一个算法，如果某个数是0结尾的，那么先计算它一共有几个末尾0，然后再看它是能被2整除还是被5整除。最后把末尾0以及能被5整除的数据个数相加即可。

但是这个算法遇到了一个问题，就是25也是能被5整除的数字，但是它乘以4可以得到两个0，按照原算法可以发现，25被当作一个5计算了，事实上25应该是两个5，125同理。

所以在计算5出现的个数时，应该要像10一样，不断的去除以5，以判断这个数由几个5构成。

最终这个算法的速度非常快，但是内存消耗尽击败了75%的人。

**总结**

程序员不应该依赖测试，程序员应该依赖期望。所以这次代码出错让我对自己很失望。我在想未来应该如何避免这样的问题。这次问题出现在25!时，0的个数与算法不符。

未来应该如何避免这样的问题呢？